generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model users {
  id                   Int                 @id @default(autoincrement())
  name                 String              @db.VarChar(100)
  email                String              @unique @db.VarChar(254)
  password             String              @db.VarChar(100)
  address              String?             @db.VarChar(250)
  birthday             DateTime            @db.Timestamp(3)
  city                 String?             @db.VarChar(35)
  isAdmin              Boolean?            @default(false)
  picture              String?
  document             String?
  // documentId    String? // es factible este campo ??
  lastUpdatedBy        Int                 @db.Integer
  lastUpdatedOn        DateTime?           @db.Timestamp(3)
  roleId               Int
  roles                roles               @relation("userRoles", fields: [roleId], references: [id])
  socialSecurity       String              @db.VarChar(9)
  startDate            DateTime            @db.Timestamp(3)
  state                String              @db.VarChar(50)
  statusId             Int
  status               userStatus          @relation("userStatus", fields: [statusId], references: [id])
  telephone            String              @db.VarChar(15)
  zipcode              String              @db.VarChar(9)
  refreshToken         String?             @db.VarChar(200)
  userPermitId         Int
  userPermits          userPermits         @relation("userPermits", fields: [userPermitId], references: [id])
  newsClosed           news[]              @relation("userNewsClosed")
  newsCreated          news[]              @relation("userNewsCreated")
  newsPending          news[]              @relation("userNewsPending")
  notesCreated         notes[]             @relation("userNoteCreated")
  settingsCreated      settings[]          @relation("userSettingCreated")
  eventsCreated        events[]            @relation("userEventCreated")
  userProductCreated   products[]          @relation("userProductCreated")
  userProductUpdated   products[]          @relation("userProductUpdated")
  userProvidersUpdated productProviders[]  @relation("userProvidersUpdated")
  userProvidersCreated productProviders[]  @relation("userProvidersCreated")
  userStockCreated     stock[]             @relation("userStockCreated")
  userStockUpdated     stock[]             @relation("userStockUpdated")
  userMovementCreated  inventoryMovement[] @relation("inventoryMovementUserCreated")
  userMovementUpdated  inventoryMovement[] @relation("inventoryMovementUserUpdated")
  userPurchaseCreated  purchase[]          @relation("userPurchaseCreated")
  userPurchaseUpdated  purchase[]          @relation("userPurchaseUpdated")
  userSaleCreated      sale[]              @relation("userSaleCreated")
  userSaleUpdated      sale[]              @relation("userSaleUpdated")
  userClientCreated    clients[]           @relation("userClientCreated")
  userClientUpdated    clients[]           @relation("userClientUpdated")
  userEmployeeCreated  employees[]          @relation("userEmployeeCreated")
  userEmployeeUpdated  employees[]          @relation("userEmployeeUpdated")
}

model userPermits {
  id                  Int      @id @default(autoincrement())
  accessConfiguration Boolean? @default(false)
  accessNews          Boolean? @default(false)
  users               users[]  @relation("userPermits")
}

model roles {
  id          Int     @id @default(autoincrement())
  code        String  @unique @db.VarChar(3)
  description String  @unique @db.VarChar(50)
  users       users[] @relation("userRoles")
}

model userStatus {
  id          Int     @id @default(autoincrement())
  code        String  @unique @db.VarChar(3)
  description String  @unique @db.VarChar(8)
  users       users[] @relation("userStatus")
}

model notes {
  id              Int         @id @default(autoincrement())
  updatedOn       DateTime?   @db.Timestamp(3)
  createdOn       DateTime    @db.Timestamp(3)
  title           String      @db.VarChar(50)
  content         String      @db.VarChar(2000)
  color           String      @db.VarChar(6)
  columnId        Int         @db.Integer
  columnStatus    noteColumns @relation("noteColumns", fields: [columnId], references: [id])
  userNoteCreated users       @relation("userNoteCreated", fields: [createdBy], references: [id])
  createdBy       Int         @db.Integer
}

model noteColumns {
  id    Int     @id @default(autoincrement())
  title String  @db.VarChar(15)
  code  String  @unique @db.VarChar(3)
  notes notes[] @relation("noteColumns")
}

model newsStatus {
  id          Int    @id @default(autoincrement())
  code        String @unique @db.VarChar(3)
  description String @unique @db.VarChar(10)
  news        news[] @relation("newsStatus")
}

model news {
  id              Int        @id @default(autoincrement())
  closedOn        DateTime?  @db.Timestamp(3)
  createdOn       DateTime   @db.Timestamp(3)
  pendingOn       DateTime?  @db.Timestamp(3)
  description     String     @db.VarChar(400)
  document        String?
  documentId      String?
  // questions       questions[]
  status          newsStatus @relation("newsStatus", fields: [statusId], references: [id])
  statusId        Int        @db.Integer
  userNewsClosed  users?     @relation("userNewsClosed", fields: [closedBy], references: [id])
  closedBy        Int?       @db.Integer
  userNewsPending users?     @relation("userNewsPending", fields: [pendingBy], references: [id])
  pendingBy       Int?       @db.Integer
  userNewsCreated users      @relation("userNewsCreated", fields: [createdBy], references: [id])
  createdBy       Int        @db.Integer
}

model settings {
  id                 Int       @id @default(autoincrement())
  displayEvents      Boolean?  @default(false)
  displayNotes       Boolean?  @default(false)
  displayNews        Boolean?  @default(false)
  displayProfile     Boolean?  @default(false)
  displayLanguage    Boolean?  @default(false)
  displayReports     Boolean?  @default(false)
  displayPayroll     Boolean?  @default(false)
  displayStock       Boolean?  @default(false)
  language           String?   @db.VarChar(2)
  userSettingCreated users     @relation("userSettingCreated", fields: [userId], references: [id])
  userId             Int       @db.Integer
  createdOn          DateTime  @default(now()) @db.Timestamp(3)
  updatedOn          DateTime? @db.Timestamp(3)
}

model events {
  id               Int        @id @default(autoincrement())
  title            String     @db.VarChar(50)
  description      String     @db.VarChar(200)
  speaker          String?    @db.VarChar(20)
  startTime        String     @db.VarChar(5)
  endTime          String     @db.VarChar(5)
  eventDate        DateTime   @db.Timestamp(3)
  userEventCreated users      @relation("userEventCreated", fields: [createdBy], references: [id])
  createdBy        Int        @db.Integer
  createdOn        DateTime   @db.Timestamp(3)
  updatedOn        DateTime?  @db.Timestamp(3)
  eventTypes       eventTypes @relation("eventTypes", fields: [eventTypeId], references: [id])
  eventTypeId      Int
}

model eventTypes {
  id          Int      @id @default(autoincrement())
  code        String   @unique @db.VarChar(3)
  description String   @unique @db.VarChar(10)
  events      events[] @relation("eventTypes")
}

model products {
  id                 Int                 @id @default(autoincrement())
  sku                String              @unique @db.VarChar(16)
  name               String              @db.VarChar(80)
  productCategories  productCategories   @relation("productCategories", fields: [productCategoryId], references: [id])
  productCategoryId  Int                 @db.Integer
  productProviders   productProviders    @relation("productProviders", fields: [productProviderId], references: [id])
  productProviderId  Int                 @db.Integer
  price              Decimal             @db.Decimal(10, 2)
  cost               Decimal             @db.Decimal(10, 2)
  description        String?             @db.VarChar(2000)
  productStatus      productStatus       @relation("productStatus", fields: [productStatusId], references: [id])
  productStatusId    Int                 @db.Integer
  barCode            String?             @unique @db.VarChar(25)
  userProductCreated users               @relation("userProductCreated", fields: [createdBy], references: [id])
  createdBy          Int                 @db.Integer
  createdOn          DateTime            @db.Timestamp(3)
  updatedOn          DateTime?           @db.Timestamp(3)
  userProductUpdated users?              @relation("userProductUpdated", fields: [updatedBy], references: [id])
  updatedBy          Int?                @db.Integer
  productAttributes  productAttributes[] @relation("productAttributes")
  stock              stock[]             @relation("stockProduct")
  inventoryMovement  inventoryMovement[] @relation("inventoryMovementProduct")
  purchaseDetail     purchaseDetail[]    @relation("purchaseDetailProduct")
  saleDetail         saleDetail[]        @relation("saleDetailProduct")

}

model productCategories {
  id          Int        @id @default(autoincrement())
  code        String     @unique @db.VarChar(3)
  description String     @unique @db.VarChar(50)
  createdOn   DateTime   @db.Timestamp(3)
  updatedOn   DateTime?  @db.Timestamp(3)
  products    products[] @relation("productCategories")
}

model productProviders {
  id                   Int        @id @default(autoincrement())
  code                 String     @unique @db.VarChar(3)
  name                 String     @unique @db.VarChar(100)
  createdOn            DateTime   @db.Timestamp(3)
  userProvidersCreated users?     @relation("userProvidersCreated", fields: [createdBy], references: [id])
  createdBy            Int        @db.Integer
  userProvidersUpdated users?     @relation("userProvidersUpdated", fields: [updatedBy], references: [id])
  updatedBy            Int?       @db.Integer
  updatedOn            DateTime?  @db.Timestamp(3)
  status               Boolean    @default(true)
  contactName          String?    @db.VarChar(60)
  contactEmail         String?    @unique @db.VarChar(80)
  contactPhone         String?    @db.VarChar(15)
  address              String?    @db.VarChar(120)
  products             products[] @relation("productProviders")
  purchase             purchase[] @relation("purchaseProvider")
}

model productStatus {
  id          Int        @id @default(autoincrement())
  code        String     @unique @db.VarChar(3)
  description String     @unique @db.VarChar(10)
  products    products[] @relation("productStatus")
}

model productAttributes {
  id          Int       @id @default(autoincrement())
  name        String    @db.VarChar(50)
  description String    @db.VarChar(100)
  createdOn   DateTime  @db.Timestamp(3)
  productId   Int // Clave for√°nea
  product     products  @relation("productAttributes", fields: [productId], references: [id], onDelete: Cascade)
}

//ALMACEN
model warehouse {
  id                Int                 @id @default(autoincrement())
  name              String              @db.VarChar(50)
  description       String?             @db.VarChar(120)
  address           String?             @db.VarChar(120)
  status            warehouseStatus     @default(ACTIVE)
  createdOn         DateTime            @db.Timestamp(3)
  updatedOn         DateTime?           @db.Timestamp(3)
  stock             stock[]             @relation("stockWarehouse")
  inventoryMovement inventoryMovement[] @relation("inventoryMovementWarehouse")

}

//ALMACEN STATUS
enum warehouseStatus {
  ACTIVE
  INACTIVE
  MAINTENANCE
}

// quantity * priceUnit = totalCost
model stock {
  id               Int              @id @default(autoincrement())
  quantity         Int              @default(0)
  minimum          Int              @default(0)
  maximum          Int?             @db.Integer
  lot              String?          @db.VarChar(50) // identificador
  unitMeasure      unitMeasureStock @default(PIECES)
  expirationDate   DateTime?        @db.Timestamp(3)
  product          products         @relation("stockProduct", fields: [productId], references: [id])
  productId        Int              @db.Integer 
  warehouse        warehouse        @relation("stockWarehouse", fields: [warehouseId], references: [id])
  warehouseId      Int              @db.Integer
  createdOn        DateTime         @db.Timestamp(3)
  updatedOn        DateTime?        @db.Timestamp(3)
  userStockCreated users            @relation("userStockCreated", fields: [createdBy], references: [id])
  createdBy        Int              @db.Integer
  userStockUpdated users?           @relation("userStockUpdated", fields: [updatedBy], references: [id])
  updatedBy        Int?             @db.Integer
  @@unique([productId, warehouseId, lot, expirationDate], name: "unique_stock_entry") // Permite m√∫ltiples registros solo si lote, producto, almacen y caducidad es distinto
}

enum unitMeasureStock {
  PIECES
  KILOGRAMS
  LITERS
  METERS
}

// üîÑ Movimientos de Inventario
model inventoryMovement {
  id          Int   @id @default(autoincrement())
  productId  Int   @db.Integer
  warehouseId   Int   @db.Integer
  quantity    Int   @db.Integer
  type        movementType
  reason      String?  @db.VarChar(200)
  product    products @relation("inventoryMovementProduct", fields: [productId], references: [id])
  warehouse     warehouse  @relation("inventoryMovementWarehouse", fields: [warehouseId], references: [id])
  createdOn    DateTime @db.Timestamp(3)
  createdBy    Int      @db.Integer
  userMovementCreated     users  @relation("inventoryMovementUserCreated", fields: [createdBy], references: [id])
  updatedOn    DateTime? @db.Timestamp(3)
  updatedBy    Int?     @db.Integer
  userMovementUpdated     users?  @relation("inventoryMovementUserUpdated", fields: [updatedBy], references: [id])
  purchase   purchase? @relation("inventoryMovementPurchase", fields: [purchaseId], references: [id])
  purchaseId Int? @db.Integer
  sale   sale? @relation("inventoryMovementSale", fields: [saleId], references: [id])
  saleId Int? @db.Integer

}

enum movementType {
  ENTRY
  EXIT
  TRANSFERENCE
  ADJUSTMENT
}

// üõí Compras
model purchase {
  id           Int       @id @default(autoincrement())
  providerId  Int @db.Integer
  total        Decimal @db.Decimal(18, 2)
  createdOn    DateTime @db.Timestamp(3)
  updatedOn    DateTime? @db.Timestamp(3)
  purchaseDetail    purchaseDetail[] @relation("purchaseDetail")
  provider    productProviders    @relation("purchaseProvider", fields: [providerId], references: [id])
  userPurchaseCreated users @relation("userPurchaseCreated", fields: [createdBy], references: [id])
  createdBy Int @db.Integer
  userPurchaseUpdated users? @relation("userPurchaseUpdated", fields: [updatedBy], references: [id])
  updatedBy Int? @db.Integer
  inventoryMovement inventoryMovement[] @relation("inventoryMovementPurchase")
}

model purchaseDetail {
  id         Int   @id @default(autoincrement())
  purchaseId   Int
  productId Int
  quantity   Int
  price     Decimal @db.Decimal(18, 2)
  purchase     purchase   @relation("purchaseDetail", fields: [purchaseId], references: [id])
  product   products @relation("purchaseDetailProduct", fields: [productId], references: [id])
}

// üõç Ventas
model sale {
  id          Int        @id @default(autoincrement())
  clientId    Int @db.Integer
  client     clients @relation("saleClient", fields: [clientId], references: [id])
  total       Decimal @db.Decimal(18, 2)
  createdOn    DateTime @db.Timestamp(3)
  updatedOn    DateTime? @db.Timestamp(3)
  saleDetail   saleDetail[] @relation("saleDetail")
  inventoryMovement inventoryMovement[] @relation("inventoryMovementSale")
  userSaleCreated users @relation("userSaleCreated", fields: [createdBy], references: [id])
  createdBy Int @db.Integer
  userSaleUpdated users? @relation("userSaleUpdated", fields: [updatedBy], references: [id])
  updatedBy Int? @db.Integer
}
model clients {
  id Int @id @default(autoincrement())
  name String @db.VarChar(100)
  email String @db.VarChar(100)
  phone String @db.VarChar(15)
  address String @db.VarChar(120)
  createdOn DateTime @db.Timestamp(3)
  updatedOn DateTime? @db.Timestamp(3)
  userClientCreated users @relation("userClientCreated", fields: [createdBy], references: [id])
  createdBy Int @db.Integer
  userClientUpdated users? @relation("userClientUpdated", fields: [updatedBy], references: [id])
  updatedBy Int? @db.Integer
  sale sale[] @relation("saleClient")
}

model saleDetail {
  id         Int   @id @default(autoincrement())
  saleId    Int @db.Integer
  productId Int @db.Integer
  quantity   Int @db.Integer
  price     Decimal @db.Decimal(18, 2)
  sale      sale    @relation("saleDetail", fields: [saleId], references: [id])
  product   products @relation("saleDetailProduct", fields: [productId], references: [id])
}




model employees {
  id          Int   @id @default(autoincrement())
  name      String @db.VarChar(100)
  lastName    String @db.VarChar(100)
  dni         String   @unique @db.VarChar(10)
  phone    String? @db.VarChar(15)
  email       String   @unique @db.VarChar(100)
  address   String? @db.VarChar(120)
  startDate DateTime @db.Timestamp(3)
  position       String @db.VarChar(100)
  department String @db.VarChar(100)
  salary     Decimal @db.Decimal(18, 2)
  userEmployeeCreated users? @relation("userEmployeeCreated", fields: [createdBy], references: [id]) // Relaci√≥n opcional con Usuario
  createdBy   Int?   @db.Integer // Si el empleado tiene una cuenta de usuario, se almacena aqu√≠
  userEmployeeUpdated users? @relation("userEmployeeUpdated", fields: [updatedBy], references: [id]) // Relaci√≥n opcional con Usuario
  updatedBy   Int?   @db.Integer // Si el empleado tiene una cuenta de usuario, se almacena aqu√≠
  attendance  attendance[] @relation("attendanceEmployee")
  payroll      payroll[] @relation("payrollEmployee")
  performanceEvaluations performanceEvaluation[] @relation("performanceEvaluationEmployee")
  vacations  vacation[] @relation("vacationEmployee")
  permissions    permission[] @relation("permissionEmployee")
  createdOn   DateTime  @db.Timestamp(3)
  updatedOn   DateTime? @db.Timestamp(3)
}

model attendance {
  id          Int   @id @default(autoincrement())
  employeeId  Int @db.Integer
  date       DateTime @db.Timestamp(3)
  entryTime        String     @db.VarChar(5)
  exitTime          String     @db.VarChar(5)
  workedHours Decimal @db.Decimal(18, 2)
  employee    employees @relation("attendanceEmployee", fields: [employeeId], references: [id])
  createdOn   DateTime @db.Timestamp(3)
  updatedOn   DateTime? @db.Timestamp(3)
}

model payroll {
  id          Int   @id @default(autoincrement())
  employeeId  Int @db.Integer
  month        Int @db.Integer
  year        Int @db.Integer
  baseSalary  Decimal @db.Decimal(18, 2)
  extraHours  Decimal @db.Decimal(18, 2)
  deductions  Decimal @db.Decimal(18, 2)
  totalPayment   Decimal @db.Decimal(18, 2)
  employee    employees @relation("payrollEmployee", fields: [employeeId], references: [id])
  createdOn   DateTime @db.Timestamp(3)
  updatedOn   DateTime? @db.Timestamp(3)
}

model performanceEvaluation {
  id          Int   @id @default(autoincrement())
  employeeId  Int @db.Integer
  date       DateTime @db.Timestamp(3)
  calification Int @db.Integer
  comments String? @db.VarChar(200)
  employee    employees @relation("performanceEvaluationEmployee", fields: [employeeId], references: [id])
  createdOn   DateTime @db.Timestamp(3)
  updatedOn   DateTime? @db.Timestamp(3)
}

model vacation {
  id          Int   @id @default(autoincrement())
  employeeId  Int @db.Integer
  startDate  DateTime @db.Timestamp(3)
  endDate    DateTime @db.Timestamp(3)
  status      vacationStatus @default(PENDING)
  employee    employees @relation("vacationEmployee", fields: [employeeId], references: [id])
  createdOn   DateTime @db.Timestamp(3)
  updatedOn   DateTime? @db.Timestamp(3)
}

enum vacationStatus {
  PENDING
  APPROVED
  REJECTED
}

model permission {
  id          Int   @id @default(autoincrement())
  employeeId  Int @db.Integer
  type        String @db.VarChar(100) // Licencia m√©dica, asuntos personales, etc.
  startDate DateTime @db.Timestamp(3)
  endDate    DateTime @db.Timestamp(3)
  status      permissionStatus @default(PENDING)
  employee    employees @relation("permissionEmployee", fields: [employeeId], references: [id])
  createdOn   DateTime @db.Timestamp(3)
}

enum permissionStatus {
  PENDING
  APPROVED
  REJECTED
}


